# -*- coding: utf-8 -*-
"""
Spyder Editor

This is a temporary script file.
"""

import rebound
import numpy as np
from rebound import hash as h
import matplotlib.pyplot as plt


def rhill(m,mstar,a):
    #m=mass of particle, mstar=mass of star, a=semimajor axis
    return a*( m/(3.*mstar) )**(1./3.) 

def planet_distance(n,m,mstar):
    a = np.zeros(n) #n zero entries
    a[0] = 0.1 #first entry is 0.1AU #the closest orbit is 0.1AU
    r_hill_0 = rhill(m,mstar,a[0]) #call rhill def with m,mstar,a[0](=0.1)
    a_range = np.linspace(0,4.9,1000) ################################
    for i in range(1,n): #range from 1 to n. since 0 entry is already filled, filling from [1]
        #a[i] = a[i-1] + 3.3*rhill(m,mstar,a[i-1]) # fill the i entry with previous entry+rhill function
        a[i] = a[i-1] + np.random.choice(a_range) ###################################
    return a # after filling all entries with rhill equation, return the array

def setupSimulation(n,m,mstar):
    #n=number of particles, m = mass of particles, mstar=mass of star
    sim = rebound.Simulation()
    sim.add(m=mstar, hash='Sun',r=4.6e-3) # m(mass of particle)= mstar, r=radius??
    ls = 2.*np.pi*np.random.rand(n) #creat random number n entries of an array in range [0,1)
    #specify random positions along the orbit as longitude(경도)
    a = planet_distance(n,m,mstar) #calling planet_distance def
    #after creating new set of a by using rhill and planet_distance, use for loop to creat new particles
    [sim.add(m=m, a=a[i], l=ls[i], hash=i+1, r=(50.0*4.66e-4)) for i in range(n)]
    sim.move_to_com() #REBOUND transform the particle coordinates to the barycentric(무게중심) frame for us
########make text file that save initial condition####
    return sim #return new set particles

def energy_offset(sim,E0):
    dE = abs((sim.calculate_energy()-E0)/E0)
    return dE


G = 6.67e-8
AU = 1.5e13
Rj = 50.0*7.0e9
Msun = 2.0e30
def v_esc(m):
    return (2.0*G*m*Msun/Rj)**0.5
    
def v_kep(a):
    omega = ( (G*Msun)/(a*AU)**3.0 )**0.5
    return a*AU*omega


def run_simulations(number_of_runs, t_max, number_of_particles, m_particles, m_stellar,sim_label):
    # open file to save data
    f = open('foo%d.txt' %sim_label,'w')
    print(f)
    f.write("index   a    e    i    energy_error    n_final   close_encounters  particle_mass\n")

    for sim_count in range(number_of_runs):
    
        sim = setupSimulation(number_of_particles,m_particles,m_stellar)
    

        # not necessary yet - this saves the simulations to binaries
        #infile = "/home/renata/rebound/examples/sim_bins/sa%d.bin" %sim_count
        #print(infile)
        #sim.initSimulationArchive(infile,interval=1000.)

        max_time = t_max

        sim.exit_max_distance=30.
        Noutputs=1000
        times=np.linspace(0,max_time*2.*np.pi,Noutputs)
        #sim.dt = 1. # timestep

        sim.collision="direct"
        sim.collision_resolve="merge"

        sim.track_energy_offset = 1
        E0 = sim.calculate_energy()
        #print("Energy: {}".format(E0))

        semimajor_axes = np.zeros((number_of_particles,Noutputs))

        # note: this is how they do it in the examples, later maybe re-write it with purely hashes
        # i.e. loop through the particles like: 
        # ds = [(item.x**2.0+item.y**2.0+item.z**2.0) for item in sim.particles]
        # mask = ds>sim.exit_max_distance**2
        # for mask_index,count in enumerate(mask):
        # if count:
        # sim.remove(index=mask_index)
        # (to do)

        for i,time in enumerate(times):
            try:
                sim.integrate(time)
            except rebound.Escape as error:
                #print(error)
                #print(sim.t/(2.0*np.pi))
                for j in range(sim.N):
                    p = sim.particles[j]
                    d2 = p.x*p.x+p.y*p.y+p.z*p.z 
                    if d2>sim.exit_max_distance**2:
                        index=j
                        #print(d2)
                sim.remove(index=index)
                sim.move_to_com()

            # loop through the particles
            # if they're still left, then the 'a' value is recorded
            # otherwise, a 0 is recorded
            # record the semimajor axes of the particles
            # start with k=1, because we want planets and not the Sun
            # for the semimajor_axes, the particles start at 0
            
            
            for k in range(number_of_particles):
                try:
                    semimajor_axes[k][i] = sim.particles[h(k+1)].a
                except rebound.ParticleNotFound as error:
                    semimajor_axes[k][i] = 0  
                    
                   

        # for each simulation, output a plot of the distances (to check stability)
        fig,ax = plt.subplots()


        [ax.plot(times/(2.0*np.pi),item,label=i) for i,item in enumerate(semimajor_axes)]
        plt.legend()
        plt.title("{0} particles;{1}mass;foo{2};run{3}".format(sim.N-1,m_particles,sim_label,sim_count))
        ax.set_xlabel("Years")
        ax.set_ylabel("semimajor axis")
        ax.set_yscale('log')
        print("mass:{}".format(m_particles))
        #plt.ylim(0,10)

        #plt.savefig("/home/renata/rebound/examples/a/a%d/distances%d.png" %(sim_label,sim_count))
        #plt.close(fig)#############################
        en_error = energy_offset(sim,E0)
        close_encounters = sim.ri_hermes._steps_miniactive

        # after each simulation ends, write final orbital elements to file
#[f.write("%d %2.3f %2.3f %2.3f %f %d %1.1f %2.4f\n"% (sim_count,item.a,item.e,item.inc,en_error,sim.N,close_encounters,item.m)) for item in sim.particles[1:]]
        for item in sim.particles[1:]:
            f.write("%d %2.3f %2.3f %2.3f %f %d %1.1f %2.4f\n"% (sim_count,item.a,item.e,item.inc,en_error,sim.N,close_encounters,item.m))
            f0 = v_esc(item.m)/v_kep(item.a)
            if item.e<f0:
                plt.close(fig)
            else: 
                plt.savefig('fig{0}_{1}.pdf'.format(sim_count,item.hash))
    
        #[f.write("%d %2.3f %2.3f %2.3f %f %d\n"% (h(item.hash).value,item.a,item.e,item.inc,en_error,sim.N)) for item in sim.particles[1:]]
        print("position of star: {},{}".format(sim.particles[0].x,sim.particles[0].y))
        #print("Particles left: {}".format(sim.N))
        print("runs:",sim_count+1,"th run")

        #print(sim.calculate_energy())



        print("Number of particles remaining: {}\n".format(sim.N))
        #b = [item.hash for item in sim.particles]
        #print("Hashes of particles remaining: {}".format(b))
        #c = [item.a for item in sim.particles[1:]]
        #print("Semimajor axis:{}".format(c))
        #sim.status()


    f.close()
    
    return 0






n_runs = 10
t_max = 1.0e3
m_planet = 0.005
m_star = 1.
n_planets = 10

sim_label=0
run_simulations(n_runs, t_max, n_planets, m_planet, m_star,sim_label)
print ("end")








